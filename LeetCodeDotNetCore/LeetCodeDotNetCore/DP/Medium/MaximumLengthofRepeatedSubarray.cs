using System;
namespace LeetCodeDotNetCore.DP.Medium
{
    /*
     * 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

        示例：

        输入：
        A: [1,2,3,2,1]
        B: [3,2,1,4,7]
        输出：3
        解释：
        长度最长的公共子数组是 [3, 2, 1] 。
 

        提示：

        1 <= len(A), len(B) <= 1000
        0 <= A[i], B[i] < 100
        通过次数40,218提交次数74,582
     */
    public class LongestSubsequence
    {
        /*
         * 单看 A 、B数组的最后一项，如果它们俩不一样，公共子数组不包括它们俩—— 以它们俩为末尾项形成的公共子数组的长度为0 ：dp[i][j] = 0
        如果他们俩一样，以它们俩为末尾项的公共子数组，长度至少为 1 —— dp[i][j] 至少为 1，考虑它们俩前面的数组「能为它们俩提供多大的公共长度」—— dp[i-1][j-1]
        它们俩的前缀数组的【末尾项】不相同，即它们的前一项不相同，前缀数组提供的公共长度为 0 —— dp[i-1][j-1] = 0
        以它们俩为末尾项的公共子数组的长度 = 0 + 1 —— dp[i][j] = 0 + 1
        如果它们俩的前缀数组的【末尾项】相同
        前缀部分能提供的公共长度—— dp[i-1][j-1] ，至少为 1
        加上它们俩本身的长度 1 ，就是以它们俩为末尾项的公共子数组的长度 dp[i][j] = dp[i-1][j-1] + 1

         */
        public int Solution(int[] A, int[] B)
        {
            var dp = new int[A.Length + 1][];
            for (var i = 0; i < dp.Length; i++)
            {
                dp[i] = new int[B.Length + 1];
            }
            var res = 0;
            for (var i = 1; i <= A.Length; i++)
                for (var j = 1; j <= B.Length; j++)
                {
                    //判断两个数组组成的矩阵，每个交点的两个元素是否相等
                    //实际上就是两个当前的两个遍历到的数组的值相等
                    if (A[i - 1] == B[j - 1])
                    {
                        //如果相等的话，交点的值就等于左上方交点的值+1
                        //既然当前的两个遍历到的数组的值相等，那么当前dp值就要等于上一个遍历到的A和B数组的判断结果加1
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    }
                    //拿到当前最大值
                    res = Math.Max(res, dp[i][j]);
                }
            return res;
        }
    }
}
